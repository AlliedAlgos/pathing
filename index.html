<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>AlliedPath</title>
<script src="https://cdn.tailwindcss.com"></script>
<link href="https://fonts.googleapis.com/css2?family=Space+Mono:wght@400;700&family=Bebas+Neue&display=swap" rel="stylesheet">
<style>
  body { font-family: 'Space Mono', monospace; }
  canvas { cursor: crosshair; display: block; }
  input[type=range] {
    -webkit-appearance: none; appearance: none;
    height: 4px; background: #0e2240; border-radius: 2px; outline: none;
  }
  input[type=range]::-webkit-slider-thumb {
    -webkit-appearance: none; appearance: none;
    width: 14px; height: 14px; border-radius: 50%;
    background: #3b9eff; cursor: pointer;
    box-shadow: 0 0 6px rgba(59,158,255,0.6);
  }
  input[type=range]::-moz-range-thumb {
    width: 14px; height: 14px; border-radius: 50%;
    background: #3b9eff; cursor: pointer; border: none;
  }
  .inp {
    background: #0d1a2a; border: 1px solid #1e3a5f; color: #3b9eff;
    font-family: 'Space Mono', monospace; font-size: 0.72rem;
    padding: 3px 5px; outline: none; text-align: center; width: 100%;
    border-radius: 999px;
  }
  .inp:focus { border-color: #3b9eff; }
  .lbl { font-size: 0.48rem; letter-spacing: 2px; color: #4a6080; text-transform: uppercase; }
  ::-webkit-scrollbar { width: 4px; height: 4px; }
  ::-webkit-scrollbar-track { background: #040c18; }
  ::-webkit-scrollbar-thumb { background: #1e3a5f; }
</style>
</head>
<body class="bg-[#040c18] text-gray-200 flex h-screen overflow-hidden">

<!-- SIDEBAR -->
<div class="flex flex-col w-56 min-w-[14rem] bg-[#070e1c] border-r border-[#0e2240] p-3 gap-3 overflow-hidden shrink-0">

  <!-- Logo -->
  <div class="font-['Bebas_Neue'] text-[2rem] tracking-widest leading-none select-none" style="text-shadow:0 0 18px rgba(59,158,255,0.35)">
    <span style="color:#ffffff">ALLIED</span><span style="color:#3b9eff">PATH</span>
  </div>

  <!-- Cursor pill -->
  <div class="bg-[#0a1929] rounded-full px-4 py-2 flex items-center justify-between">
    <span class="lbl">Cursor</span>
    <div id="hover-display" class="text-[#3b9eff] text-xs tracking-wide">—</div>
  </div>

  <!-- Vehicle size pill group -->
  <div class="bg-[#0a1929] rounded-2xl px-3 py-2 flex flex-col gap-2">
    <div class="lbl px-1">Vehicle Size (in)</div>
    <div class="flex items-center justify-between bg-[#060d1a] rounded-full px-3 py-1">
      <span class="text-[0.6rem] text-[#4a6080]">Width</span>
      <input type="number" id="rect-width" value="24" min="1" max="999" class="inp" style="width:52px">
    </div>
    <div class="flex items-center justify-between bg-[#060d1a] rounded-full px-3 py-1">
      <span class="text-[0.6rem] text-[#4a6080]">Length</span>
      <input type="number" id="rect-length" value="48" min="1" max="999" class="inp" style="width:52px">
    </div>
  </div>

  <!-- Points list pill group -->
  <div class="bg-[#0a1929] rounded-2xl px-3 py-2 flex flex-col gap-2 flex-1 min-h-0">
    <div class="lbl px-1">Points (<span id="count">0</span>) <span class="normal-case text-[#1e3a5f]">click to edit</span></div>
    <div id="points-list" class="overflow-y-auto flex flex-col gap-1.5 flex-1"></div>
  </div>

  <!-- Action buttons -->
  <div class="flex flex-col gap-2">
    <button onclick="saveFile()" class="rounded-full text-[0.6rem] tracking-widest uppercase bg-[#0d1e36] border border-[#1e3a5f] text-[#3b9eff] py-2 hover:bg-[#1a3a6a] hover:border-[#3b9eff] transition-all flex items-center justify-center gap-2">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" class="w-3 h-3"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></svg>
      Save File
    </button>
    <button onclick="clearAll()" class="rounded-full text-[0.6rem] tracking-widest uppercase bg-[#0a1929] border border-[#1e3a5f] text-[#4a6080] py-2 hover:border-[#ff3355] hover:text-[#ff3355] hover:bg-[#1a0a12] transition-all">
      Clear All
    </button>
  </div>
</div>

<!-- MAIN -->
<div class="flex-1 flex flex-col min-w-0 overflow-hidden">

  <!-- Canvas area -->
  <div class="flex-1 overflow-auto bg-[#040c18]" id="canvas-wrap">
    <div id="grid-container" class="inline-flex flex-col items-start p-3">
      <div class="flex flex-row">
        <canvas id="yaxis-canvas"></canvas>
        <canvas id="main-canvas"></canvas>
      </div>
      <canvas id="xaxis-canvas"></canvas>
    </div>
  </div>

  <!-- Playback controls -->
  <div class="border-t border-[#0e2240] bg-[#060d1a] px-4 py-3">
    <div class="flex items-center gap-4">

      <!-- Play/Pause -->
      <button id="play-btn" onclick="togglePlay()"
        class="w-9 h-9 flex items-center justify-center border border-[#1e3a5f] text-[#3b9eff] hover:border-[#3b9eff] hover:shadow-[0_0_8px_rgba(59,158,255,0.4)] transition-all shrink-0">
        <svg id="play-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" class="w-4 h-4"><path d="M8 5v14l11-7z"/></svg>
        <svg id="pause-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" class="w-4 h-4 hidden"><path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/></svg>
      </button>

      <!-- Slider -->
      <div class="flex-1 flex flex-col gap-1">
        <input type="range" id="progress-slider" min="0" max="1000" value="0" class="w-full" oninput="onSliderInput(this.value)">
        <div class="flex justify-between text-[0.5rem] text-[#2a4060]">
          <span>Start</span>
          <span id="progress-label">0%</span>
          <span>End</span>
        </div>
      </div>

      <!-- Speed -->
      <div class="flex flex-col items-center gap-1 shrink-0">
        <div class="lbl">Speed</div>
        <select id="speed-select" class="bg-[#0d1a2a] border border-[#1e3a5f] text-[#3b9eff] text-xs px-1 py-1 outline-none font-['Space_Mono']">
          <option value="0.5">0.5×</option>
          <option value="1" selected>1×</option>
          <option value="2">2×</option>
          <option value="4">4×</option>
        </select>
      </div>

      <!-- Live heading -->
      <div class="flex flex-col items-center gap-1 shrink-0 w-20">
        <div class="lbl">Heading</div>
        <div id="heading-display" class="text-[#3b9eff] text-sm">—°</div>
      </div>

      <!-- Live position -->
      <div class="flex flex-col items-center gap-1 shrink-0 w-28">
        <div class="lbl">Position (in)</div>
        <div id="pos-display" class="text-[#3b9eff] text-xs">—</div>
      </div>
    </div>
  </div>
</div>

<script>
// ─── CONFIG ───────────────────────────────────────────────────────────────────
const COLS = 93, ROWS = 45;
const BG_URL = 'https://static.wixstatic.com/media/41532e_7822743521f7432aae59f69bd7fa9444~mv2.png/v1/fill/w_888,h_508,al_c/41532e_7822743521f7432aae59f69bd7fa9444~mv2.png';

// ─── CANVAS REFS ──────────────────────────────────────────────────────────────
const mainCanvas  = document.getElementById('main-canvas');
const yaxisCanvas = document.getElementById('yaxis-canvas');
const xaxisCanvas = document.getElementById('xaxis-canvas');
const ctx  = mainCanvas.getContext('2d');
const yCtx = yaxisCanvas.getContext('2d');
const xCtx = xaxisCanvas.getContext('2d');

// ─── UI REFS ──────────────────────────────────────────────────────────────────
const hoverDisplay  = document.getElementById('hover-display');
const pointsList    = document.getElementById('points-list');
const countEl       = document.getElementById('count');
const progressSlider= document.getElementById('progress-slider');
const progressLabel = document.getElementById('progress-label');
const headingDisplay= document.getElementById('heading-display');
const posDisplay    = document.getElementById('pos-display');
const playIcon      = document.getElementById('play-icon');
const pauseIcon     = document.getElementById('pause-icon');

// ─── STATE ────────────────────────────────────────────────────────────────────
let points   = [];
let playing  = false;
let progress = 0;
let animFrame= null;
let lastTime = null;
let CELL     = 10;

// ─── BG IMAGE ─────────────────────────────────────────────────────────────────
const BG_IMG = new Image();
BG_IMG.crossOrigin = 'anonymous';
BG_IMG.src = BG_URL;
BG_IMG.onload = () => render();

// ─── SIZING ───────────────────────────────────────────────────────────────────
function getCellSize() {
  const sidebarW = 208;
  const availW = window.innerWidth  - sidebarW - 60;
  const availH = window.innerHeight - 100;
  const byW = Math.floor(availW / (COLS + 2));
  const byH = Math.floor(availH / (ROWS + 2));
  return Math.max(5, Math.min(14, byW, byH));
}

function gap() { return CELL >= 8 ? 1 : 0; }

function setupCanvases() {
  const g = gap();
  const W = COLS * CELL + (COLS - 1) * g + 2;
  const H = ROWS * CELL + (ROWS - 1) * g + 2;
  const YW = CELL <= 7 ? 22 : 32;
  const XH = 20;

  mainCanvas.width  = W; mainCanvas.height  = H;
  mainCanvas.style.width  = W+'px'; mainCanvas.style.height = H+'px';

  yaxisCanvas.width  = YW; yaxisCanvas.height  = H;
  yaxisCanvas.style.width  = YW+'px'; yaxisCanvas.style.height = H+'px';

  xaxisCanvas.width  = YW + W; xaxisCanvas.height  = XH;
  xaxisCanvas.style.width  = (YW+W)+'px'; xaxisCanvas.style.height = XH+'px';

  mainCanvas._yw = YW;
}

// ─── COORD HELPERS ────────────────────────────────────────────────────────────
function cellToCanvas(x, y) {
  const g = gap();
  return {
    cx: x * (CELL + g) + CELL / 2 + 1,
    cy: ((ROWS - 1) - y) * (CELL + g) + CELL / 2 + 1
  };
}

function canvasToGrid(px, py) {
  const g = gap();
  return {
    x: Math.min(Math.max(Math.floor(px / (CELL + g)), 0), COLS - 1),
    y: Math.min(Math.max((ROWS - 1) - Math.floor(py / (CELL + g)), 0), ROWS - 1)
  };
}

// ─── MATH HELPERS ─────────────────────────────────────────────────────────────
// Segment length in inches (1 cell = 1 inch)
function segLen(a, b) {
  const dx = b.x - a.x, dy = b.y - a.y;
  return Math.sqrt(dx*dx + dy*dy);
}

// Segment heading angle in canvas space (for rotation): right=0, up=pos
function segAngle(a, b) {
  return Math.atan2(-(b.y - a.y), b.x - a.x);
}

// Turn angle at point i (signed degrees: left=negative, right=positive)
function turnAngle(i) {
  if (i <= 0 || i >= points.length - 1) return null;
  const a = points[i-1], b = points[i], c = points[i+1];
  const ang1 = Math.atan2(b.y - a.y, b.x - a.x);
  const ang2 = Math.atan2(c.y - b.y, c.x - b.x);
  let delta = (ang2 - ang1) * 180 / Math.PI;
  // Normalize to -180..180
  while (delta >  180) delta -= 360;
  while (delta < -180) delta += 360;
  return delta;
}

// Heading in degrees (0=East, 90=North, counter-clockwise)
function segHeadingDeg(a, b) {
  const rawDeg = Math.atan2(b.y - a.y, b.x - a.x) * 180 / Math.PI;
  return ((rawDeg) % 360 + 360) % 360;
}

function getTotalLength() {
  let len = 0;
  for (let i = 1; i < points.length; i++) len += segLen(points[i-1], points[i]);
  return len;
}

function getPositionAtProgress(t) {
  if (points.length < 2) return null;
  const total = getTotalLength();
  if (total === 0) return null;
  const target = t * total;
  let acc = 0;
  for (let i = 1; i < points.length; i++) {
    const sl = segLen(points[i-1], points[i]);
    if (acc + sl >= target || i === points.length - 1) {
      const local = sl > 0 ? (target - acc) / sl : 0;
      const x = points[i-1].x + (points[i].x - points[i-1].x) * local;
      const y = points[i-1].y + (points[i].y - points[i-1].y) * local;
      const angle = segAngle(points[i-1], points[i]);
      const headDeg = segHeadingDeg(points[i-1], points[i]);
      return { x, y, angle, headDeg };
    }
    acc += sl;
  }
  return null;
}

// ─── DRAW ─────────────────────────────────────────────────────────────────────
function draw() {
  const g = gap();
  ctx.clearRect(0, 0, mainCanvas.width, mainCanvas.height);

  // Background image — raw, no overlay
  if (BG_IMG.complete && BG_IMG.naturalWidth > 0) {
    ctx.drawImage(BG_IMG, 0, 0, mainCanvas.width, mainCanvas.height);
  } else {
    ctx.fillStyle = '#060d1a';
    ctx.fillRect(0, 0, mainCanvas.width, mainCanvas.height);
  }

  // Subtle grid overlay
  ctx.strokeStyle = 'rgba(59,158,255,0.10)';
  ctx.lineWidth = 0.5;
  for (let c = 0; c <= COLS; c++) {
    const px = c * (CELL + g) + 1;
    ctx.beginPath(); ctx.moveTo(px, 0); ctx.lineTo(px, mainCanvas.height); ctx.stroke();
  }
  for (let r = 0; r <= ROWS; r++) {
    const py = r * (CELL + g) + 1;
    ctx.beginPath(); ctx.moveTo(0, py); ctx.lineTo(mainCanvas.width, py); ctx.stroke();
  }

  // Axis highlight lines
  ctx.strokeStyle = 'rgba(59,158,255,0.25)';
  ctx.lineWidth = 1;
  const axX = 0 * (CELL + g) + 1;
  ctx.beginPath(); ctx.moveTo(axX, 0); ctx.lineTo(axX, mainCanvas.height); ctx.stroke();
  const axY = (ROWS - 1) * (CELL + g) + 1;
  ctx.beginPath(); ctx.moveTo(0, axY); ctx.lineTo(mainCanvas.width, axY); ctx.stroke();

  // ── Draw path segments with distance labels ──
  if (points.length >= 2) {
    for (let i = 1; i < points.length; i++) {
      const { cx: x1, cy: y1 } = cellToCanvas(points[i-1].x, points[i-1].y);
      const { cx: x2, cy: y2 } = cellToCanvas(points[i].x,   points[i].y);
      const dist = segLen(points[i-1], points[i]);

      // Line
      ctx.beginPath();
      ctx.strokeStyle = '#3b9eff';
      ctx.lineWidth = Math.max(1.5, CELL * 0.18);
      ctx.lineJoin = 'round'; ctx.lineCap = 'round';
      ctx.shadowColor = 'rgba(59,158,255,0.45)';
      ctx.shadowBlur = 6;
      ctx.moveTo(x1, y1); ctx.lineTo(x2, y2);
      ctx.stroke();
      ctx.shadowBlur = 0;

      // Distance label at midpoint
      const mx = (x1 + x2) / 2;
      const my = (y1 + y2) / 2;
      const angle = Math.atan2(y2 - y1, x2 - x1);
      const labelText = dist.toFixed(1) + '"';
      const fs = Math.max(8, CELL * 0.72);

      ctx.save();
      ctx.translate(mx, my);
      // Keep text readable (flip if pointing left)
      let rot = angle;
      if (rot > Math.PI/2 || rot < -Math.PI/2) rot += Math.PI;
      ctx.rotate(rot);

      // Label pill background
      ctx.font = `bold ${fs}px Space Mono, monospace`;
      const tw = ctx.measureText(labelText).width;
      const pad = 3;
      ctx.fillStyle = 'rgba(4,12,24,0.82)';
      ctx.beginPath();
      ctx.roundRect(-(tw/2+pad), -(fs/2+pad), tw+pad*2, fs+pad*2, 3);
      ctx.fill();

      ctx.fillStyle = '#7ecfff';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(labelText, 0, 0);
      ctx.restore();
    }
  }

  // ── Draw points ──
  points.forEach((p, i) => {
    const { cx, cy } = cellToCanvas(p.x, p.y);
    const fs = Math.max(7, CELL * 0.58);

    // Point square
    ctx.fillStyle = '#3b9eff';
    ctx.shadowColor = 'rgba(59,158,255,0.7)';
    ctx.shadowBlur = 5;
    ctx.fillRect(cx - CELL/2, cy - CELL/2, CELL, CELL);
    ctx.shadowBlur = 0;

    // Point number
    if (CELL >= 7) {
      ctx.fillStyle = '#fff';
      ctx.font = `bold ${fs}px monospace`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(i + 1, cx, cy);
    }

    // Heading arrow — shows the heading stored on the point
    const headingDeg = p.heading ?? 0;
    const headingRad = headingDeg * Math.PI / 180;
    const arrowLen = Math.max(CELL * 1.6, 10);
    const arrowX = cx + Math.cos(headingRad) * arrowLen;
    const arrowY = cy - Math.sin(headingRad) * arrowLen; // canvas y is flipped

    ctx.save();
    ctx.strokeStyle = '#ffe066';
    ctx.lineWidth = Math.max(1, CELL * 0.14);
    ctx.shadowColor = 'rgba(255,220,80,0.5)';
    ctx.shadowBlur = 4;
    ctx.beginPath();
    ctx.moveTo(cx, cy);
    ctx.lineTo(arrowX, arrowY);
    ctx.stroke();

    // Arrowhead
    const aw = Math.max(3, CELL * 0.35);
    const ang = Math.atan2(arrowY - cy, arrowX - cx);
    ctx.fillStyle = '#ffe066';
    ctx.shadowBlur = 0;
    ctx.beginPath();
    ctx.moveTo(arrowX, arrowY);
    ctx.lineTo(arrowX - aw * Math.cos(ang - 0.4), arrowY - aw * Math.sin(ang - 0.4));
    ctx.lineTo(arrowX - aw * Math.cos(ang + 0.4), arrowY - aw * Math.sin(ang + 0.4));
    ctx.closePath();
    ctx.fill();

    // Heading degree label next to arrow tip
    const lfs2 = Math.max(7, CELL * 0.6);
    const labelOffX = Math.cos(headingRad) * (arrowLen + lfs2 * 0.4);
    const labelOffY = -Math.sin(headingRad) * (arrowLen + lfs2 * 0.4);
    ctx.font = `bold ${lfs2}px Space Mono, monospace`;
    ctx.fillStyle = '#ffe066';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    // Pill bg
    const htxt = headingDeg + '°';
    const htw = ctx.measureText(htxt).width;
    const hpad = 2;
    ctx.fillStyle = 'rgba(4,12,24,0.8)';
    ctx.beginPath();
    ctx.roundRect(cx + labelOffX - htw/2 - hpad, cy + labelOffY - lfs2/2 - hpad, htw + hpad*2, lfs2 + hpad*2, 2);
    ctx.fill();
    ctx.fillStyle = '#ffe066';
    ctx.fillText(htxt, cx + labelOffX, cy + labelOffY);
    ctx.restore();

    // Turn angle label at intermediate points
    const turn = turnAngle(i);
    if (turn !== null) {
      const sign = turn >= 0 ? '+' : '';
      const label = sign + turn.toFixed(1) + '°';
      const lfs = Math.max(8, CELL * 0.7);

      // Position above/offset from the point
      const labelX = cx + CELL * 1.1;
      const labelY = cy - CELL * 1.1;

      ctx.font = `bold ${lfs}px Space Mono, monospace`;
      const tw = ctx.measureText(label).width;
      const pad = 3;

      ctx.fillStyle = 'rgba(4,12,24,0.85)';
      ctx.beginPath();
      ctx.roundRect(labelX - pad, labelY - lfs/2 - pad, tw + pad*2, lfs + pad*2, 3);
      ctx.fill();

      // Color: green for left turn, orange for right
      ctx.fillStyle = turn >= 0 ? '#44ff99' : '#ffaa33';
      ctx.textAlign = 'left';
      ctx.textBaseline = 'middle';
      ctx.fillText(label, labelX, labelY);
    }
  });

  // ── Animated rectangle ──
  if (points.length >= 2) {
    const pos = getPositionAtProgress(progress);
    if (pos) {
      const { cx, cy } = cellToCanvas(pos.x, pos.y);
      const rw = (parseFloat(document.getElementById('rect-width').value)  || 24) * CELL;
      const rl = (parseFloat(document.getElementById('rect-length').value) || 48) * CELL;

      ctx.save();
      ctx.translate(cx, cy);
      ctx.rotate(pos.angle);

      ctx.shadowColor = 'rgba(255,190,0,0.45)';
      ctx.shadowBlur = 14;
      ctx.fillStyle = 'rgba(255,200,0,0.11)';
      ctx.fillRect(-rl/2, -rw/2, rl, rw);
      ctx.strokeStyle = '#ffc800';
      ctx.lineWidth = Math.max(1, CELL * 0.15);
      ctx.strokeRect(-rl/2, -rw/2, rl, rw);

      ctx.shadowBlur = 0;
      ctx.fillStyle = '#ffc800';
      ctx.beginPath();
      ctx.arc(0, 0, Math.max(2, CELL * 0.28), 0, Math.PI*2);
      ctx.fill();

      // Arrow
      const aw = Math.max(4, CELL * 0.45);
      ctx.beginPath();
      ctx.moveTo(rl/2, 0);
      ctx.lineTo(rl/2 - aw, -aw*0.6);
      ctx.lineTo(rl/2 - aw,  aw*0.6);
      ctx.closePath();
      ctx.fill();

      ctx.restore();

      headingDisplay.textContent = pos.headDeg.toFixed(1) + '°';
      posDisplay.textContent = `(${pos.x.toFixed(1)}", ${pos.y.toFixed(1)}")`;
    }
  }
}

function drawAxes() {
  const g = gap();
  const YW = mainCanvas._yw || 32;
  const fs = Math.max(6, CELL * 0.48);

  yCtx.clearRect(0, 0, yaxisCanvas.width, yaxisCanvas.height);
  yCtx.fillStyle = '#5a80a0';
  yCtx.font = `${fs}px Space Mono, monospace`;
  yCtx.textAlign = 'right';
  yCtx.textBaseline = 'middle';
  for (let y = 0; y < ROWS; y++) {
    if (y % 5 === 0) {
      const cy = ((ROWS-1)-y)*(CELL+g) + CELL/2 + 1;
      yCtx.fillText(y+'"', YW-2, cy);
    }
  }

  xCtx.clearRect(0, 0, xaxisCanvas.width, xaxisCanvas.height);
  xCtx.fillStyle = '#5a80a0';
  xCtx.font = `${fs}px Space Mono, monospace`;
  xCtx.textAlign = 'center';
  xCtx.textBaseline = 'top';
  for (let x = 0; x < COLS; x++) {
    if (x % 5 === 0) {
      const px = YW + x*(CELL+g) + CELL/2 + 1;
      xCtx.fillText(x+'"', px, 2);
    }
  }
}

function render() { draw(); drawAxes(); }

// ─── INTERACTION ──────────────────────────────────────────────────────────────
mainCanvas.addEventListener('mousemove', e => {
  const r = mainCanvas.getBoundingClientRect();
  const { x, y } = canvasToGrid(e.clientX - r.left, e.clientY - r.top);
  hoverDisplay.textContent = `(${x}", ${y}")`;
});
mainCanvas.addEventListener('mouseleave', () => { hoverDisplay.textContent = '—'; });

mainCanvas.addEventListener('click', e => {
  const r = mainCanvas.getBoundingClientRect();
  const { x, y } = canvasToGrid(e.clientX - r.left, e.clientY - r.top);
  const idx = points.findIndex(p => p.x === x && p.y === y);
  if (idx !== -1) points.splice(idx, 1);
  else points.push({ x, y, heading: 0 });
  progress = 0;
  progressSlider.value = 0;
  progressLabel.textContent = '0%';
  renderList();
  render();
});

document.getElementById('rect-width').addEventListener('input', render);
document.getElementById('rect-length').addEventListener('input', render);

// ─── ANIMATION ────────────────────────────────────────────────────────────────
function togglePlay() {
  if (points.length < 2) return;
  playing = !playing;
  playIcon.classList.toggle('hidden', playing);
  pauseIcon.classList.toggle('hidden', !playing);
  if (playing) {
    if (progress >= 1) progress = 0;
    lastTime = null;
    animFrame = requestAnimationFrame(animate);
  } else {
    cancelAnimationFrame(animFrame);
  }
}

function animate(ts) {
  if (!lastTime) lastTime = ts;
  const dt = (ts - lastTime) / 1000;
  lastTime = ts;
  const speed = parseFloat(document.getElementById('speed-select').value);
  const total = getTotalLength();
  const duration = total > 0 ? total / (12 * speed) : 5;
  progress += dt / duration;
  if (progress >= 1) {
    progress = 1; playing = false;
    playIcon.classList.remove('hidden');
    pauseIcon.classList.add('hidden');
    progressSlider.value = 1000;
    progressLabel.textContent = '100%';
    render(); return;
  }
  progressSlider.value = Math.round(progress * 1000);
  progressLabel.textContent = Math.round(progress * 100) + '%';
  render();
  if (playing) animFrame = requestAnimationFrame(animate);
}

function onSliderInput(val) {
  progress = val / 1000;
  progressLabel.textContent = Math.round(progress * 100) + '%';
  render();
}

// ─── SIDEBAR LIST (editable) ──────────────────────────────────────────────────
function renderList() {
  pointsList.innerHTML = '';
  countEl.textContent = points.length;

  points.forEach((p, i) => {
    const turn = turnAngle(i);
    const turnStr = turn !== null
      ? `<span style="color:${turn>=0?'#44ff99':'#ffaa33'};font-size:0.6rem">${turn>=0?'+':''}${turn.toFixed(1)}°</span>`
      : '';
    const distStr = i < points.length - 1
      ? `<span style="color:#5a80a0;font-size:0.58rem">${segLen(points[i], points[i+1]).toFixed(1)}"→</span>`
      : '';

    const entry = document.createElement('div');
    entry.className = 'flex flex-col px-3 py-2 bg-[#060d1a] rounded-xl border border-[#0e2240] text-[#3b9eff] gap-1.5';

    // Header row with point number and delete
    const header = document.createElement('div');
    header.className = 'flex justify-between items-center text-[0.65rem]';
    header.innerHTML = `<span class="text-[#4a6080]">#${i+1}</span><span class="text-[#444] hover:text-[#ff3355] cursor-pointer del">✕</span>`;
    header.querySelector('.del').addEventListener('click', () => {
      points.splice(i, 1); renderList(); render();
    });

    // Editable X/Y row
    const coords = document.createElement('div');
    coords.className = 'flex items-center gap-1 text-[0.65rem]';

    // X input
    const xWrap = document.createElement('div');
    xWrap.className = 'flex items-center gap-0.5';
    xWrap.innerHTML = '<span class="text-[#4a6080]">x</span>';
    const xInp = document.createElement('input');
    xInp.type = 'number'; xInp.value = p.x; xInp.min = 0; xInp.max = COLS-1;
    xInp.className = 'inp'; xInp.style.width = '44px'; xInp.style.fontSize = '0.65rem'; xInp.style.padding = '2px 3px';
    xInp.addEventListener('change', () => {
      const v = Math.min(Math.max(parseInt(xInp.value)||0, 0), COLS-1);
      xInp.value = v; points[i].x = v; renderList(); render();
    });
    xWrap.appendChild(xInp);

    // Y input
    const yWrap = document.createElement('div');
    yWrap.className = 'flex items-center gap-0.5';
    yWrap.innerHTML = '<span class="text-[#4a6080]">y</span>';
    const yInp = document.createElement('input');
    yInp.type = 'number'; yInp.value = p.y; yInp.min = 0; yInp.max = ROWS-1;
    yInp.className = 'inp'; yInp.style.width = '44px'; yInp.style.fontSize = '0.65rem'; yInp.style.padding = '2px 3px';
    yInp.addEventListener('change', () => {
      const v = Math.min(Math.max(parseInt(yInp.value)||0, 0), ROWS-1);
      yInp.value = v; points[i].y = v; renderList(); render();
    });
    yWrap.appendChild(yInp);

    coords.appendChild(xWrap);
    coords.appendChild(yWrap);

    // Heading input
    const hWrap = document.createElement('div');
    hWrap.className = 'flex items-center gap-0.5';
    hWrap.innerHTML = '<span class="text-[#4a6080]">h°</span>';
    const hInp = document.createElement('input');
    hInp.type = 'number'; hInp.value = p.heading ?? 0; hInp.min = -360; hInp.max = 360; hInp.step = 1;
    hInp.className = 'inp'; hInp.style.width = '44px'; hInp.style.fontSize = '0.65rem'; hInp.style.padding = '2px 3px';
    hInp.title = 'Heading in degrees (0=right, 90=up, 180=left, -90=down)';
    hInp.addEventListener('change', () => {
      let v = parseFloat(hInp.value) || 0;
      v = ((v % 360) + 360) % 360;
      if (parseFloat(hInp.value) < 0) v = v - 360; // keep negative if user typed negative
      hInp.value = v; points[i].heading = v; renderList(); render();
    });
    hWrap.appendChild(hInp);
    coords.appendChild(hWrap);

    // Info row (turn + dist)
    const info = document.createElement('div');
    info.className = 'flex gap-2';
    info.innerHTML = `${turnStr}${distStr}`;

    entry.appendChild(header);
    entry.appendChild(coords);
    if (turnStr || distStr) entry.appendChild(info);

    pointsList.appendChild(entry);
  });
}

// ─── SAVE FILE ────────────────────────────────────────────────────────────────
function saveFile() {
  const html = document.documentElement.outerHTML;
  const blob = new Blob([html], { type: 'text/html' });
  const url  = URL.createObjectURL(blob);
  const a    = document.createElement('a');
  a.href = url;
  a.download = 'alliedpath.html';
  a.click();
  URL.revokeObjectURL(url);
}

function clearAll() {
  points = []; progress = 0;
  progressSlider.value = 0;
  progressLabel.textContent = '0%';
  playing = false;
  playIcon.classList.remove('hidden');
  pauseIcon.classList.add('hidden');
  cancelAnimationFrame(animFrame);
  renderList();
  render();
}

// ─── INIT ─────────────────────────────────────────────────────────────────────
function init() {
  CELL = getCellSize();
  setupCanvases();
  render();
}

window.addEventListener('resize', () => {
  clearTimeout(window._rt);
  window._rt = setTimeout(init, 150);
});

init();
</script>
</body>
</html>
